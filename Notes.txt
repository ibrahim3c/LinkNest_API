Validators 
	how to execute them

U can not make query or command for mulitple handlers

in ngsql u should make the query like this 
                SELECT
                "Content" as Content, // "content"  or Content is wrong 
                "CreatedAt" AS CreatedAt,
                "UserProfileId" as UserProfileId
                from "PostComment"
                where "postId"=@PostId

Please don't make the response class internal like this:
    internal class GetPostInteractionsResponse
    {
        public Guid PostId { get; init; }
        public List<InteractionInfo> InteractionInfos { get; init; }
    }
    Because when I try to return this response from the controller, it cannot be accessed.

Make commands and queries public 
Make data types of commands or queries is primtive  

i don't understand validaion behavior :()




/*
    Flow Between Frontend and Backend
    User Requests a Password Reset
        Frontend:
            User enters their email in a "Forgot Password" form.
            Frontend sends a POST request to ForgotPasswordAsync endpoint with the email.
        Backend (ForgotPasswordAsync)
            Checks if the email exists.
            Generates a password reset token.
            Sends an email with a reset link (SendPasswordResetEmailAsync).
            Returns a success message: "Please go to your email and reset your password".
    User Clicks the Reset Link in Email
        Frontend:
            Extracts userId and code from the URL.
            Displays a password reset form for the user to enter a new password.
    User Submits the New Password
        Frontend:
            Sends a POST request to ResetPasswordAsync with userId, code, and newPassword.
        Backend (ResetPasswordAsync)
            Validates input.
            Finds the user.
            Decodes the reset token.
            Resets the password using userManager.ResetPasswordAsync().
            Returns a success message: "Password Reset successfully".
    */


Steps to implement Doamin Event
    1 - in domain layer 
        define IDomainEvent interface
        add those in base class
            public IReadOnlyList<IDomainEvent> GetDomainEvents() => _events;
            public void RaiseDomainEvent(IDomainEvent domainEvent) => _events.Add(domainEvent);
            public void ClearDomainEvents()=>_events.Clear();
        in each domain layer define a record for specific event happen to it like when user created
        so we will create record called UserCreatedDomainEvent :IDomainEvent
        and we add to to the collection in the right time like in method of created after we create the user we will add this event
    
    2 - in application layer
        define a handler of this domain event like UserCreatedDomainEventHandler:INotificationHandler<UserCreatedDomainEvent> 
        and handlee this event for example send welcome to him

    3 - In Infrastructure Layer (or Persistence Layer)
        Modify AppDbContext to dispatch domain events after saving changes

Event Flow Summary
    1 - The domain logic raises a domain event by calling RaiseDomainEvent(...).
    2 - The event is stored in a private _events list inside the entity.
    3 - When SaveChangesAsync() is called in the DbContext:
        It collects all domain events.
        Saves changes to the database.
        Then publishes the events via MediatR.
    4 - MediatR automatically invokes the appropriate handler(s) for each domain event.
    5 - The logic inside the handler (e.g., sending an email, logging, etc.) is executed.
    6 - The events are then cleared from the entity.


there are two options to handle domain validation
    1- use exceptions
        so you can throw exception in domain layer and catch it in application layer and return it to the user
        it is simple and easy to implement and easier debugging but less performance 
        and recommeded to use custom exceptions like DomainException or ValidationException
    2- use error objects
        so you can return error object from domain layer and check it in application layer and return it to the user
        i think this approach is better because it is more explicit and readable and better performance 
        and you can return multiple errors at once but less debugging where no stack trace
        and it is called Result or Result<T> pattern
    we will use the first approach now and later we will use the second approach

steps to implement handling domain validation using exceptions
    1 - in domain layer
        define a custom exception like DomainException or ValidationException
        and throw it in the right place like when user tries to create a user with existing email
    2 - in presentation layer
        catch this exception using global exception handler and return it to the user

steps to implement send notification using oneSignal: go to https://onesignal.com/ 
    1- add in secret.json the oneSignal section containing the appId and apiKey
    2- in application layer create a class to map the data in secret.json to this class to use it as a configuration
    3- in application layer add IClass to send notification like INotificationService or IOneSignalService
    4- in infrastructure layer implement this interface and use HttpClient to send the request to OneSignal API
    5- i used this service in DomainEventHandlers to send notification such as when comment created
    note: we use userId as externalUserId in OneSignal API to identify the user and this id is registered when user registers in the app 
    and this is resposibility of the frontend to register the user in OneSignal and get the externalUserId

steps to implement Permission Authorization in https://youtube.com/playlist?list=PLYpjLpq5ZDGtJOHUbv7KHuxtYLk1nJPw5&si=-BmDOnxVdZYXFmJM
    1- in infra layer add in Auth folder 
        HasPermissionAttribute Class
        Permission Enum
    2- assign the role to the user and assign specific permissions to the role
        add Permission Table and its configuration file
        add RolePermission Table and its configuration file
        Seed the permissions in the database
        Seed permissions and roles permissions in the database using seeder classes
    3- in infra layer add in auth foldere a handler to check the permission and there are two ways to handle 
        1- using a permission service that checks the permission for the user in db
            pros: always up to date u don't need to update the JWT token or wait refresh token
            cons: more database calls and less performance                                                                                      
        2- add permission to the user as claims when we generate JWT and check it in the handler
            pros: less database calls and better performance
            cons: need to update the JWT token or wait refresh token to update the permissions
                  and if  u have a large number of permissions it will increase the size of the token and this token will be sent in every request so it will increase the size of the request
    4- using first approach u will add a IPermissionService interface in application layer and implement it in infrastructure layer
        use this service in handler to check the permission for the user
        add configuration of permission authorization in dependency injection in application layer
    4- using second approach u will go to function that generate jwt token and inject in its class IPermissionService and get the permissions for the user
        and add them as claims to the token
        and then check permission in claims of token in the handler
    5- add custom provider for permission authorization in infra layer
        and register it in dependency injection

An AuthorizationHandler is always executed, even if the user is not authenticated.
    That means inside your handler you should:
        Check if the user is authenticated first.
        If not → don’t call context.Succeed → the framework will return 401 Unauthorized.
        Then check authorization (permissions/roles).
        If the user is authenticated but missing permission → no context.Succeed → returns 403 Forbidden.
        If the user has the required permission → call context.Succeed → access granted.
    So:Handler must handle both Authentication and Authorization checks.


if u get this error Unauthorized - {"errors":[{"message":"Maximum credits exceeded"}]}
    it means that you have exceeded the number of requests to the API and you need to wait for a while or upgrade your plan
    or use alternative API like Mailjet or SMTP erver like Gmail or Outlook 

in unit tests of application layer
    u need to access the commands in app layer but this commands are internal 
    so we add in app layer xml file this code so we can access them in unit tests
	<ItemGroup>
		<AssymblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleToAttribute">
		    <_Parameter1>LinkNest.Application.UnitTests</_Parameter1>
		</AssymblyAttribute>
	</ItemGroup>

    we did unit test for domain layer and application layer
    and u can use for mocking framework like Moq or NSubstitute( recommended from someone)
        in NSubstitute he define repos interfaces and named for ex IUserRepository userRepositoryMock 
        and in constructor he did this.userRepositoryMock=Substitute.For<IUserRepository>()
        and then in each test he can setup the mock like this userRepositoryMock.GetByIdAsync(userId).Returns(user)