Validators 
	how to execute them

U can not make query or command for mulitple handlers

in ngsql u should make the query like this 
                SELECT
                "Content" as Content, // "content"  or Content is wrong 
                "CreatedAt" AS CreatedAt,
                "UserProfileId" as UserProfileId
                from "PostComment"
                where "postId"=@PostId

Please don't make the response class internal like this:
    internal class GetPostInteractionsResponse
    {
        public Guid PostId { get; init; }
        public List<InteractionInfo> InteractionInfos { get; init; }
    }
    Because when I try to return this response from the controller, it cannot be accessed.

Make commands and queries public 
Make data types of commands or queries is primtive  

i don't understand validaion behavior :()




/*
    Flow Between Frontend and Backend
    User Requests a Password Reset
        Frontend:
            User enters their email in a "Forgot Password" form.
            Frontend sends a POST request to ForgotPasswordAsync endpoint with the email.
        Backend (ForgotPasswordAsync)
            Checks if the email exists.
            Generates a password reset token.
            Sends an email with a reset link (SendPasswordResetEmailAsync).
            Returns a success message: "Please go to your email and reset your password".
    User Clicks the Reset Link in Email
        Frontend:
            Extracts userId and code from the URL.
            Displays a password reset form for the user to enter a new password.
    User Submits the New Password
        Frontend:
            Sends a POST request to ResetPasswordAsync with userId, code, and newPassword.
        Backend (ResetPasswordAsync)
            Validates input.
            Finds the user.
            Decodes the reset token.
            Resets the password using userManager.ResetPasswordAsync().
            Returns a success message: "Password Reset successfully".
    */


Steps to implement Doamin Event
    1 - in domain layer 
        define IDomainEvent interface
        add those in base class
            public IReadOnlyList<IDomainEvent> GetDomainEvents() => _events;
            public void RaiseDomainEvent(IDomainEvent domainEvent) => _events.Add(domainEvent);
            public void ClearDomainEvents()=>_events.Clear();
        in each domain layer define a record for specific event happen to it like when user created
        so we will create record called UserCreatedDomainEvent :IDomainEvent
        and we add to to the collection in the right time like in method of created after we create the user we will add this event
    
    2 - in application layer
        define a handler of this domain event like UserCreatedDomainEventHandler:INotificationHandler<UserCreatedDomainEvent> 
        and handlee this event for example send welcome to him

    3 - In Infrastructure Layer (or Persistence Layer)
        Modify AppDbContext to dispatch domain events after saving changes

Event Flow Summary
    1 - The domain logic raises a domain event by calling RaiseDomainEvent(...).
    2 - The event is stored in a private _events list inside the entity.
    3 - When SaveChangesAsync() is called in the DbContext:
        It collects all domain events.
        Saves changes to the database.
        Then publishes the events via MediatR.
    4 - MediatR automatically invokes the appropriate handler(s) for each domain event.
    5 - The logic inside the handler (e.g., sending an email, logging, etc.) is executed.
    6 - The events are then cleared from the entity.


there are two options to handle domain validation
    1- use exceptions
        so you can throw exception in domain layer and catch it in application layer and return it to the user
        it is simple and easy to implement and easier debugging but less performance 
        and recommeded to use custom exceptions like DomainException or ValidationException
    2- use error objects
        so you can return error object from domain layer and check it in application layer and return it to the user
        i think this approach is better because it is more explicit and readable and better performance 
        and you can return multiple errors at once but less debugging where no stack trace
        and it is called Result or Result<T> pattern
    we will use the first approach now and later we will use the second approach

steps to implement handling domain validation using exceptions
    1 - in domain layer
        define a custom exception like DomainException or ValidationException
        and throw it in the right place like when user tries to create a user with existing email
    2 - in presentation layer
        catch this exception using global exception handler and return it to the user

steps to implement send notification using oneSignal: go to https://onesignal.com/ 
    1- add in secret.json the oneSignal section containing the appId and apiKey
    2- in application layer create a class to map the data in secret.json to this class to use it as a configuration
    3- in application layer add IClass to send notification like INotificationService or IOneSignalService
    4- in infrastructure layer implement this interface and use HttpClient to send the request to OneSignal API
    5- i used this service in DomainEventHandlers to send notification such as when comment created

steps to implement Permission Authorization 
    1- in infra layer add in Auth folder 
        HasPermissionAttribute Class
        Permission Enum
    2- assign the role to the user and assign specific permissions to the role
        add Permission Table and its configuration file
        add RolePermission Table and its configuration file
        Seed the permissions in the database
        Seed permissions to the roles in the database

  TODO:
    authorization 
        seed RolePermissions
    solve the bug of sending email and sending notifications and add cors configuration
    test the app